use alloc::sync::Arc;

use axfs_ng_vfs::{FileNode, FileNodeOps, VfsResult};
use lru::LruCache;

use super::PAGE_SIZE;
use crate::{CachedFile, PageCache, highlevel::file::CachedFileShared};

// TODO: u32? or u64
/// default max page size (128KB / 4KB = 32 pages)
pub const RA_MAX_PAGES: u32 = 32;

/// default min page size (prevent too small IO)
pub const RA_MIN_PAGES: u32 = 2; // Linux VM_MIN_READAHEAD

/// ramp up initial scale factor
const INIT_RA_SCALE: u32 = 4;

/// ramp up factor for subsequent readahead
const RAMP_UP_SCALE: u32 = 2;

pub struct ReadaheadState {
    pub start_pn: u32,
    pub size: u32,
    pub async_size: u32,
    pub prev_pn: u32,
    pub max_pages: u32,
}

impl ReadaheadState {
    pub const fn new(max_pages: u32) -> Self {
        Self {
            start_pn: 0,
            size: 0, // disabled readahead for now
            async_size: 0,
            prev_pn: 0,
            max_pages,
        }
    }

    // NOTE: these codes are generated by copilot
    // ---------------------------------------------------------------
    /// update readahead window on cache miss
    /// # Warnings
    /// the window size should never be 0
    pub fn update_window_on_cache_miss(&mut self, trigger_pn: u32, req_size: u32) {
        // -----------------------------------------------------------
        // 1. 顺序性与抖动检测 (Classification)
        // -----------------------------------------------------------

        // A. 是否是文件开头 (Start of file)
        let is_start_of_file = trigger_pn == 0;

        // B. 是否接得上 (Sequential)
        // 注意：prev_pn 是上一次 read 的结束位置(exclusive)
        let is_sequential = trigger_pn == self.prev_pn + 1;

        // C. 是否是抖动 (Thrashing)
        // 缺页发生在了旧窗口的范围内，说明预读页被提前回收了
        // 此时必须立即重启窗口，防止退化成 1 页 IO
        let is_thrashing = trigger_pn >= self.start_pn && trigger_pn < self.start_pn + self.size;

        // 如果既不是顺序，也不是开头，也不是抖动，那就是随机读
        if !is_start_of_file && !is_sequential && !is_thrashing {
            // random read strategy: only read the requested page
            self.start_pn = trigger_pn;
            self.size = 1;
            self.async_size = 0;
            return;
        }

        // -----------------------------------------------------------
        // 2. 计算新窗口大小 (Initial / Restart Sizing)
        // -----------------------------------------------------------

        // 依据论文：size = read_size * scale
        // 即使是 Thrashing，也重新基于 req_size 慢启动，因为这能自动适应内存压力 [cite: 149]
        let scaled_size = req_size.saturating_mul(INIT_RA_SCALE);

        // 对齐优化：向上取整到 2 的幂 (可选，但推荐)
        let mut new_size = scaled_size.next_power_of_two();

        // 硬限幅：不能超过设备上限，也不能太小
        new_size = new_size.clamp(RA_MIN_PAGES, self.max_pages);

        // -----------------------------------------------------------
        // 3. 更新状态 (Update State)
        // -----------------------------------------------------------

        // 窗口起点重置为当前缺页位置 (Restart from current position)
        self.start_pn = trigger_pn;
        self.size = new_size;

        // 开启全流水线：async_size = size
        // 这意味着窗口的第一页(或附近)就会被打上 PG_readahead 标记
        self.async_size = if is_start_of_file {
            new_size - req_size
        } else {
            new_size
        };
    }

    /// 分支 2: 后续预读 (Subsequent Readahead / Ramp Up)
    /// 触发场景: 命中 PG_readahead 标记
    /// 论文来源:
    pub fn update_window_for_async(&mut self) {
        // 1. 推进窗口起点: 新起点 = 旧起点 + 旧大小
        // 必须在更新 self.size 之前执行这一步
        self.start_pn = self.start_pn.saturating_add(self.size);
        // 2. 指数倍增: size = prev_size * 2
        let mut new_size = self.size.saturating_mul(RAMP_UP_SCALE);
        // 3. 限制上限
        new_size = new_size.min(self.max_pages);
        // 4. 更新大小
        self.size = new_size;
        // 5. 保持流水线: async_size = size
        self.async_size = new_size;
    }

    /// [辅助] 获取需要打上 PG_readahead 标记的页号
    /// 公式: start + size - async_size
    pub const fn get_trigger_offset(&self) -> u32 {
        if self.size == 0 {
            return 0; // 此时不应该打标
        }
        self.start_pn + self.size - self.async_size
    }

    /// [辅助] 在 read 结束时更新 prev_pn
    pub const fn update_history(&mut self, last_read_pn: u32) {
        self.prev_pn = last_read_pn;
    }

    // end of copilot generated code
    // ---------------------------------------------------------------
}

pub(super) trait Readahead {
    /// find cache from cache
    fn find_page_from_cache<'a>(
        &self,
        caches: &'a mut LruCache<u32, PageCache>,
        pn: u32,
    ) -> Option<(&'a mut PageCache, Option<u32>)>;
}

impl Readahead for CachedFile {
    fn find_page_from_cache<'a>(
        &self,
        caches: &'a mut LruCache<u32, PageCache>,
        pn: u32,
    ) -> Option<(&'a mut PageCache, Option<u32>)> {
        match caches.get_mut(&pn) {
            Some(cache) => {
                let mut new_pg_pn = None;
                if cache.pg_readahead {
                    cache.pg_readahead = false;
                    let mut ra = self.ra_state.lock();
                    ra.update_window_for_async();
                    new_pg_pn = Some(ra.get_trigger_offset());
                }
                Some((cache, new_pg_pn))
            }
            None => None,
        }
    }
}

pub fn async_prefetch(
    cache_shared: Arc<CachedFileShared>,
    file: Arc<dyn FileNodeOps>,
    in_memory: bool,
    start_pn: u32,
    size: u32,
    async_pg_pn: u32,
) {
    let _ = io_submit(
        &cache_shared,
        &FileNode::new(file),
        in_memory,
        start_pn,
        size,
        async_pg_pn,
    );
}

/// TODO: here we keep the lock for too long, but just to keep the same with [CachedFile::page_or_insert]
pub fn io_submit(
    cache_shared: &CachedFileShared,
    file: &FileNode,
    in_memory: bool,
    start_pn: u32,
    size: u32,
    async_pg_pn: u32,
) -> VfsResult<()> {
    for pn in start_pn..(start_pn + size) {
        let mut caches = cache_shared.page_cache.lock();
        if caches.contains(&pn) {
            continue;
        }

        // Evict LRU page if cache is full
        if caches.len() == caches.cap().get() {
            if let Some((evict_pn, mut evicted_page)) = caches.pop_lru() {
                cache_shared.evict_cache(file, evict_pn, &mut evicted_page)?;
            }
        }

        let mut page = PageCache::new()?;

        // Set the flag on the trigger page
        if pn == async_pg_pn {
            page.pg_readahead = true;
        }

        if in_memory {
            page.data().fill(0);
        } else {
            file.read_at(page.data(), pn as u64 * PAGE_SIZE as u64)?;
        }
        caches.put(pn, page);
    }
    Ok(())
}
